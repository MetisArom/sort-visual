#ifndef SORTER_H
#define SORTER_H

#include <iostream>
#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>

//template <typename T>
class Sorter {
    //OVERVIEW: sorter using an vector with various sorting algorithm members
public:

    Sorter(int size){
        capacity = size;
        vec = std::vector<int>(capacity);
        vec_reset = std::vector<int>(capacity);
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using bubble sort technique w/ swap helper function
    void bubble_sort(){
        std::cout << "Bubble Sort O(n^2)\n";
        for(int i = 0; i < vec.size()-1; i++){
            bool swapped = false;
            for(int j = 0; j < vec.size()-1; j++){
                if(vec[j] > vec[j+1]){
                    swap(vec[j], vec[j+1]);
                    swapped = true;
                }
            }
            if(!swapped) break;
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using heap sort technique ...
    void heap_sort(){
        std::cout << "Hello\n";
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using insertion sort technique w/ swap helper function
    void insertion_sort(){
        std::cout << "Insertion Sort O(n^2)\n";
        int j, recent;
        for(int i = 1; i < vec.size(); i++){
            j = i-1;
            recent = vec[j+1];
            while(j>-1 && recent < vec[j]){
                swap(vec[j], vec[j+1]);
                j--;
            }
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using merge sort technique w/ merge helper function
    void merge_sort(std::vector<int>& merge_vector, int l, int r){
        if(r+1-l == 50){std::cout << "Merge Sort O(nlog(n))\n";}

        if(l < r){
            int m = (l + (r-1))/2;

            merge_sort(merge_vector, l, m);
            merge_sort(merge_vector, m+1, r);

            merge(merge_vector, l, m, r);
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using quicksort technique ...
    void quick_sort(){
        std::cout << "Hello\n";
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using selection sort technique and swap helper function
    void selection_sort(){
        std::cout << "Selection Sort O(n^2)\n";
        for(int i = 0; i < vec.size(); i++){
            int min_idx = i;
            for(int j = i; j < vec.size(); j++){
                if(vec[j] < vec[min_idx]){
                    min_idx = j;
                }
            }
            swap(vec[i],vec[min_idx]);
        }
    }

    // REQUIRES : Initialized Sorter
    // MODIFIES : Output Stream
    // EFFECTS  : Provides output of the Sorter's vector to os placed in function parameters
    void print(std::ostream &os){
        for(int i : vec){
            os << i << " ";
        }
        os << "\n";
    }

    // REQUIRES : Initialized Sorter
    // MODIFIES : this->vec, this->vec_reset
    // EFFECTS  : Uses random seed based on time to provide psuedorandom values to the
    //            Sorter's vector and changing the reset vector.
    void randomize(){
        srand (time(NULL));
        for(int i = 0; i < capacity; i++){
            this->vec[i] = (rand() % 100) + 1;
        }
        vec_reset = vec;
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using C++ built in implementation of quicksort(?).
    void built_in_sort(){
        std::cout << "Testing Built in Sort (Quicksort)\n";
        std::sort(vec.begin(), vec.end());
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sets the Sorter's vector to the original vector generated by the last
    //            use of this->randomize()
    void reset(){
        vec = vec_reset;
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : None
    // EFFECTS  : Returns the Sorter's vector, used in merge sort implementation
    std::vector<int> return_vec(){
        return vec;
    }

private:
    std::vector<int> vec;
    int capacity = 0;
    std::vector<int> vec_reset;

    // REQUIRES : Two separate references
    // MODIFIES : a, b
    // EFFECTS  : Swaps elements by reference using a temp variable 
    void swap(int & a, int & b){
        if(&a != &b){
            int temp = a;
            a = b;
            b = temp;
        }
    }

    // REQUIRES : Valid call from merge_sort with left bound, middle, amd right bound indexes
    // MODIFIES : this->vec (nonstatic member), merge_vector
    // EFFECTS  : Uses subvectors of merge_vector to this-> vec sort using two pointer method
    void merge(std::vector<int>& merge_vector, int l, int m, int r){
        int i,j,k; //indexes
        
        int size_left = m-l+1;
        int size_right = r - m;
        
        std::vector<int> left, right;

        for(i=0; i<size_left; i++){
            left.push_back(merge_vector[l+i]);
        }
        for(j=0; j<size_right; j++){
            right.push_back(merge_vector[m+1+j]);
        }

        i=0, j=0, k=l;
        
        while(i < size_left && j < size_right){
            if(left[i] <= right[j]){
                merge_vector[k] = left[i];
                i++;
            }
            else{
                merge_vector[k] = right[j];
                j++;
            }
            k++;
        }

        while(i < size_left){
            merge_vector[k] = left[i];
            i++; k++;
        }
        while(j < size_right){
            merge_vector[k] = right[j];
            j++; k++;
        }

        vec = merge_vector;
    }
};

#endif
