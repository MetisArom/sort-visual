#ifndef SORTER_H
#define SORTER_H

#include <iostream>
#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>

//template <typename T>
class Sorter {
    //OVERVIEW: sorter using an vector with various sorting algorithm members
public:

    Sorter(int size){
        capacity = size;
        vec = std::vector<int>(capacity);
        vec_reset = std::vector<int>(capacity);
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using bubble sort technique w/ swap helper function
    void bubble_sort(){
        std::cout << "Bubble Sort O(n^2)\n";
        for(int i = 0; i < vec.size()-1; i++){
            bool swapped = false;
            for(int j = 0; j < vec.size()-1; j++){
                if(vec[j] > vec[j+1]){
                    swap(vec[j], vec[j+1]);
                    swapped = true;
                }
            }
            if(!swapped) break;
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using heap sort technique ...
    void heap_sort(){
        std::cout << "Hello\n";
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using insertion sort technique w/ swap helper function
    void insertion_sort(){
        std::cout << "Insertion Sort O(n^2)\n";
        int j, recent;
        for(int i = 1; i < vec.size(); i++){
            j = i-1;
            recent = vec[j+1];
            while(j>-1 && recent < vec[j]){
                swap(vec[j], vec[j+1]);
                j--;
            }
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using merge sort technique w/ merge helper function
    void merge_sort(int l, int r){
        if(r+1-l == 50){std::cout << "Merge Sort O(nlog(n))\n";}

        if(l < r){
            int m = (l + (r-1))/2;

            merge_sort(l, m);
            merge_sort(m+1, r);

            merge(l, m, r);
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using quicksort technique ...
    void quick_sort(int low, int high){
        if(high-low+1 == capacity){std::cout << "Quicksort O(nlog(n))\n";}
        if(low < high){
            int partition_idx = partition(low, high);

            quick_sort(low, partition_idx-1);
            quick_sort(partition_idx+1, high);
        }
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using selection sort technique and swap helper function
    void selection_sort(){
        std::cout << "Selection Sort O(n^2)\n";
        for(int i = 0; i < vec.size(); i++){
            int min_idx = i;
            for(int j = i; j < vec.size(); j++){
                if(vec[j] < vec[min_idx]){
                    min_idx = j;
                }
            }
            swap(vec[i],vec[min_idx]);
        }
    }

    // REQUIRES : Initialized Sorter
    // MODIFIES : Output Stream
    // EFFECTS  : Provides output of the Sorter's vector to os placed in function parameters
    void print(std::ostream &os){
        for(int i : vec){
            os << i << " ";
        }
        os << "\n";
    }

    // REQUIRES : Initialized Sorter
    // MODIFIES : this->vec, this->vec_reset
    // EFFECTS  : Uses random seed based on time to provide psuedorandom values to the
    //            Sorter's vector and changing the reset vector.
    void randomize(){
        srand (time(NULL));
        for(int i = 0; i < capacity; i++){
            this->vec[i] = (rand() % 100) + 1;
        }
        vec_reset = vec;
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sorts vector using C++ built in implementation of quicksort(?).
    void built_in_sort(){
        std::cout << "Testing Built in Sort (Quicksort)\n";
        std::sort(vec.begin(), vec.end());
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Sets the Sorter's vector to the original vector generated by the last
    //            use of this->randomize()
    void reset(){
        vec = vec_reset;
    }

    // REQUIRES : Initialized Sorter and the member function randomize to fill the vector
    // MODIFIES : None
    // EFFECTS  : Returns the Sorter's vector
    std::vector<int> return_vec(){
        return vec;
    }

private:
    std::vector<int> vec;
    std::vector<int> vec_reset;
    int capacity = 0;

    // REQUIRES : Two separate references
    // MODIFIES : a, b
    // EFFECTS  : Swaps elements by reference using a temp variable 
    void swap(int & a, int & b){
        if(&a != &b){
            int temp = a;
            a = b;
            b = temp;
        }
    }

    // REQUIRES : Valid call from merge_sort with left bound, middle, amd right bound indexes
    // MODIFIES : this->vec (nonstatic member)
    // EFFECTS  : Uses subvectors of vec to sort and combine into vec using two pointer method
    void merge(int l, int m, int r){
        int i,j,k; //indexes
        
        int size_left = m-l+1;
        int size_right = r - m;
        
        std::vector<int> left, right;

        for(i=0; i<size_left; i++){
            left.push_back(vec[l+i]);
        }
        for(j=0; j<size_right; j++){
            right.push_back(vec[m+1+j]);
        }

        i=0, j=0, k=l;
        
        while(i < size_left && j < size_right){
            if(left[i] <= right[j]){
                vec[k] = left[i];
                i++;
            }
            else{
                vec[k] = right[j];
                j++;
            }
            k++;
        }

        while(i < size_left){
            vec[k] = left[i];
            i++; k++;
        }
        while(j < size_right){
            vec[k] = right[j];
            j++; k++;
        }
    }

    // REQUIRES : Valid call from quick_sort with low index and high index
    // MODIFIES : this->vec (nonstatic member), partition_idx in func quick_sort()
    // EFFECTS  : Sets pivot to value at highest index, swaps elements lower than
    //            the pivot value with iterator i until iterator j has fully travered.
    //            Then, pivot is sorted at index i+1, which is returned as the index of
    //            partition in the recursive calls in the parent quick_sort function.
    int partition(int low, int high){
        int pivot = vec[high];
        int i = low-1;
        for(int j = low; j < high; j++){
            if(vec[j] < pivot){
                i++;
                swap(vec[i], vec[j]);
            }
        }
        swap(vec[i+1], vec[high]);
        return (i+1);
    }
};

#endif
